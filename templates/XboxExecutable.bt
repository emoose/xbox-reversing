//------------------------------------------------
//--- 010 Editor v14.0.1 Binary Template
//
//    File: XboxExecutable.bt
//   Authors: emoose
//   Version: 1.0
//   Purpose: Map out Original Xbox Executable headers (XBE)
//  Category: Executable
// File Mask: *.xbe
//  ID Bytes: 58 42 45 48
//   History: Added header structs based on game symbols for Xbox 5849
//------------------------------------------------
// TODO: 
//  - Display XOR-decrypted kernel thunk/entrypoint in template view
//  - Display TitleName in template view
//  - Decode TitleID to string form?
//  - Parse TLS directory?
//  - Display kernel thunk indexes/fn names?

DisplayFormatHex();

local uint XORKey_KernelThunks[3] = {
    0x5B6D40B6, // Retail
    0xEFB1F152, // Debug
    0x46437DCD // Beta
};
local uint XORKey_EntryPoint[3] = {
    0xA8FC57AB, // Retail
    0x94859D4B, // Debug
    0xE682F45B // Beta
};

local int XORKeyIndex = -1;

struct InitFlag
{
    DWORD MountUtilityDrive : 1;
    DWORD FormatUtilityDrive : 1;
    DWORD LimitDevkitMemory : 1;
    DWORD NoSetupHardDisk : 1;
    DWORD DontModifyHardDisk : 1;
    DWORD Unknown : 25;
    DWORD UtilityDriveClusterSize : 2; // 0 = 16K, 1 = 32K, 2 = 64K, 3 = 128K
};

typedef struct _XBEIMAGE_HEADER {
    DWORD Signature;
    UCHAR EncryptedDigest[256];
    DWORD BaseAddress;
    DWORD SizeOfHeaders;
    DWORD SizeOfImage;
    DWORD SizeOfImageHeader;
    time_t TimeDateStamp;
    DWORD CertificateOfs;
    DWORD NumberOfSections;
    DWORD SectionHeadersOfs;
    InitFlag InitFlags;
    DWORD AddressOfEntryPoint;
    DWORD TlsDirectoryOfs;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD NtBaseOfDll;
    DWORD NtSizeOfImage;
    DWORD NtCheckSum;
    time_t NtTimeDateStamp;
    DWORD DebugPathNameOfs;
    DWORD DebugFileNameOfs;
    DWORD DebugUnicodeFileNameOfs;
    DWORD XboxKernelThunkDataOfs;
    DWORD ImportDirectoryOfs;
    DWORD NumberOfLibraryVersions;
    DWORD LibraryVersionsOfs;
    DWORD XboxKernelLibraryVersionOfs;
    DWORD XapiLibraryVersionOfs;
    DWORD MicrosoftLogoOfs;
    DWORD SizeOfMicrosoftLogo;
    
    // XboxDevWiki "It only exists on XBEs built with an XDK version >= 5028."
    if (SizeOfImageHeader > 0x178)
        DWORD LibraryFeaturesOfs;
    if (SizeOfImageHeader > 0x17C)
        DWORD NumberOfLibraryFeatures;
        
    // XboxDevWiki "It only exists on XBEs built with an XDK version >= 5455."
    if (SizeOfImageHeader > 0x180)
        DWORD CodeViewDebugInfoOfs;    
} XBEIMAGE_HEADER;

typedef struct _XBEIMAGE_CERTIFICATE_KEY {
    BYTE Data[0x10];
} XBEIMAGE_CERTIFICATE_KEY;

struct MediaTypes
{
    DWORD HardDisk : 1;
    DWORD DVDX2 : 1;
    DWORD DVDCD : 1;
    DWORD CD : 1;
    DWORD DVD5_RO : 1;
    DWORD DVD9_RO : 1;
    DWORD DVD5_RW : 1;
    DWORD DVD9_RW : 1;
    DWORD Dongle : 1;
    DWORD MediaBoard : 1;
    DWORD Unknown : 20;
    DWORD NonSecureHardDisk : 1;
    DWORD NonSecureMode : 1;
};

struct Regions
{
    DWORD NorthAmerica : 1;
    DWORD Japan : 1;
    DWORD RestOfWorld : 1;
    DWORD : 28;
    DWORD Manufacturing : 1;
};

typedef struct _XBEIMAGE_CERTIFICATE {
    DWORD SizeOfCertificate;
    time_t TimeDateStamp;
    DWORD TitleID;
    WORD TitleName[40];
    DWORD AlternateTitleIDs[16];
    MediaTypes AllowedMediaTypes;
    Regions GameRegion;
    DWORD GameRatings;
    DWORD DiskNumber;
    DWORD Version;
    XBEIMAGE_CERTIFICATE_KEY LANKey;
    XBEIMAGE_CERTIFICATE_KEY SignatureKey;
    XBEIMAGE_CERTIFICATE_KEY AlternateSignatureKeys[16];
    DWORD OriginalSizeOfCertificate;
    DWORD OnlineServiceName;
} XBEIMAGE_CERTIFICATE;

struct SectionFlag
{
    DWORD Writeable : 1;
    DWORD Preload : 1;
    DWORD Executable : 1;
    DWORD InsertFile : 1;
    DWORD HeadPageReadOnly : 1;
    DWORD TailPageReadOnly : 1;
    DWORD Unknown : 26;
};

typedef struct _XBEIMAGE_SECTION
{
    SectionFlag SectionFlags;
    DWORD VirtualAddress;
    DWORD VirtualSize;
    DWORD PointerToRawData;
    DWORD SizeOfRawData;
    DWORD SectionNameOfs;
    DWORD SectionReferenceCount;
    DWORD HeadSharedPageReferenceCountOfs;
    DWORD TailSharedPageReferenceCountOfs;
    UCHAR SectionDigest[0x14];
    
    local long pos = FTell();
    FSeek(SectionNameOfs - Header.BaseAddress);
    string SectionName;
    FSeek(pos);
} XBEIMAGE_SECTION<read=ReadSection>;

string ReadSection( XBEIMAGE_SECTION& f )
{  
    return f.SectionName;
}

uint VAToOffset(uint va)
{
    if (va < Header.BaseAddress)
        return va;
    
    local int i = 0;
    local uint section_end = 0;
    if (Header.SectionHeadersOfs)
    {
        for(i = 0; i < Header.NumberOfSections; i++)
        {
            section_end = Sections[i].VirtualAddress + Sections[i].VirtualSize;
            if (Sections[i].VirtualAddress > va || va >= section_end)
                continue;
            return (va - Sections[i].VirtualAddress) + Sections[i].PointerToRawData;
        }
    }
    
    return va - Header.BaseAddress;
}

typedef struct _XBEIMAGE_LIBRARY_VERSION {
    CHAR LibraryName[8];
    WORD MajorVersion;
    WORD MinorVersion;
    WORD BuildVersion;
    WORD QFEVersion : 13;
    WORD ApprovedLibrary : 2;
    WORD DebugBuild : 1;
} XBEIMAGE_LIBRARY_VERSION<read=ReadLibraryVersion>;

string ReadLibraryVersion( XBEIMAGE_LIBRARY_VERSION& f )
{  
    string s;
    SPrintf( s, "%s v%d.%d.%d.%d", f.LibraryName, f.MajorVersion, f.MinorVersion, f.BuildVersion, f.QFEVersion);
    if (f.ApprovedLibrary == 0)
        s += " (Unapproved)";
    if (f.ApprovedLibrary == 1)
        s += " (Conditionally Approved)";
    //if (f.ApprovedLibrary == 2)
    //    s += " (Approved)";
    if (f.DebugBuild)
        s += " (Debug)";
    return s;
}

typedef struct _CV_INFO_PDB70
{
    DWORD CvSignature;
    BYTE Guid[0x10];
    DWORD Age;
    string PdbFileName;
} CV_INFO_PDB70<read=ReadCodeViewInfo>;

string ReadCodeViewInfo( CV_INFO_PDB70& f )
{  
    return f.PdbFileName;
}

XBEIMAGE_HEADER Header;
if (Header.CertificateOfs)
{
    FSeek(Header.CertificateOfs - Header.BaseAddress);
    XBEIMAGE_CERTIFICATE Certificate;
}

if (Header.SectionHeadersOfs)
{
    FSeek(Header.SectionHeadersOfs - Header.BaseAddress);
    XBEIMAGE_SECTION Sections[Header.NumberOfSections]<optimize=false>;
}

if (Header.DebugPathNameOfs)
{
    FSeek(VAToOffset(Header.DebugPathNameOfs));
    string DebugPathName;
}

if (Header.DebugFileNameOfs)
{
    FSeek(VAToOffset(Header.DebugFileNameOfs));
    string DebugFileName;
}

if (Header.DebugUnicodeFileNameOfs)
{
    FSeek(VAToOffset(Header.DebugUnicodeFileNameOfs));
    wstring DebugUnicodeFileName;
}

if (Header.LibraryVersionsOfs)
{
    FSeek(VAToOffset(Header.LibraryVersionsOfs));
    XBEIMAGE_LIBRARY_VERSION LibraryVersions[Header.NumberOfLibraryVersions];
}

if (Header.XboxKernelLibraryVersionOfs)
{
    FSeek(VAToOffset(Header.XboxKernelLibraryVersionOfs));
    XBEIMAGE_LIBRARY_VERSION KernelLibraryVersion;
}
if (Header.XapiLibraryVersionOfs)
{
    FSeek(VAToOffset(Header.XapiLibraryVersionOfs));
    XBEIMAGE_LIBRARY_VERSION XapiLibraryVersion;
}
if (Header.SizeOfImageHeader > 0x17C && Header.LibraryFeaturesOfs)
{
    FSeek(VAToOffset(Header.LibraryFeaturesOfs));
    XBEIMAGE_LIBRARY_VERSION LibraryFeatures[Header.NumberOfLibraryFeatures];
}
if (Header.SizeOfImageHeader > 0x180 && Header.CodeViewDebugInfoOfs)
{
    FSeek(VAToOffset(Header.CodeViewDebugInfoOfs));
    CV_INFO_PDB70 CodeViewDebugInfo;
}
if (Header.MicrosoftLogoOfs)
{
    FSeek(VAToOffset(Header.MicrosoftLogoOfs));
    BYTE MicrosoftLogo[Header.SizeOfMicrosoftLogo];
}

local uint ExeAddressStart = Header.BaseAddress;
local uint ExeAddressEnd = ExeAddressStart + Header.SizeOfImage;
local int i = 0;
local uint ActualKernelThunk = 0;
local uint ActualEntryPoint = 0;

for(i = 0; i < 3; i++)
{
    ActualKernelThunk = Header.XboxKernelThunkDataOfs ^ XORKey_KernelThunks[i];
    if (ActualKernelThunk >= ExeAddressStart && ActualKernelThunk + 4 < ExeAddressEnd)
    {
        ActualEntryPoint = Header.AddressOfEntryPoint ^ XORKey_EntryPoint[i];
        XORKeyIndex = i;
        break;
    }
    ActualKernelThunk = 0;
}

if (XORKeyIndex == 0)
    Printf("[+] Retail encrypted\n");
else if (XORKeyIndex == 1)
    Printf("[+] Debug encrypted\n");
else if (XORKeyIndex == 2)
    Printf("[+] Beta encrypted\n");
else
    Printf("[+] Unknown encryption!\n");
    
if (ActualKernelThunk)
    Printf("[+] XboxKernelThunkData Address: 0x%x\n", ActualKernelThunk);
if (ActualEntryPoint)
    Printf("[+] AddressOfEntryPoint: 0x%x\n", ActualEntryPoint);